#include "StateMachineLib.h"
#include <AsyncTaskLib.h>
#include <DHT.h>

// ======= Pines / Sensores =======
const uint8_t DHT_PIN = 2;    // Pin digital para DHT11
const uint8_t LDR_PIN = A0;   // Pin analógico para LDR
const uint8_t LED_PIN = 13;   // LED indicador
#define DHTTYPE DHT11         // Tipo de sensor DHT
DHT dht(DHT_PIN, DHTTYPE);    // Objeto DHT

// ======= Estados =======
enum State
{
    Inicio = 0,         // Estado inicial
    Monitoreo_th = 1,    // Monitoreo de temperatura y humedad
    Alerta = 2,          // Alerta por temperatura alta
    Monitoreo_luz = 3,   // Monitoreo de luz ambiental
    Alarma = 4           // Alarma por exceso de luz
};

// ======= Entradas (simplificadas) =======
enum Input
{
    A = 0,              // Botón A (confirmación)
    B = 1,              // Botón B (confirmación)
    Sign_Timeout = 2,    // Señal de timeout
    Unknown = 3          // Estado desconocido
};

// ======= Máquina de estados =======
StateMachine stateMachine(5, 4);  // 5 estados, 4 entradas
Input input = Input::Unknown;     // Entrada actual

// ======= Variables de sensores =======
float currentTemp = NAN;  // Almacena temperatura actual
int currentLuz = -1;      // Almacena valor de luz actual

// ======= Timeouts para transiciones automáticas =======
AsyncTask timeoutInicio(5000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutMonThToLuz(7000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutAlertaToMonTh(4000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutMonLuzToTh(2000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutAlarmaToLuz(5000, false, []() { input = Input::Sign_Timeout; });

// ======= Tareas de lectura de sensores =======
AsyncTask readDHTTask(2000, false, []() {
    float h = dht.readHumidity();
    float t = dht.readTemperature();
    currentTemp = t;
    
    if (isnan(h) || isnan(t)) {
        Serial.println("Estado: Monitoreo_th | Temp: N/A | Hum: N/A");
    } else {
        Serial.print("Estado: Monitoreo_th | Temp: ");
        Serial.print(t);
        Serial.print("C | Hum: ");
        Serial.print(h);
        Serial.println("%");
    }
});

AsyncTask readLDRTask(500, false, []() {
    int val = analogRead(LDR_PIN);
    currentLuz = val;
    Serial.print("Estado: Monitoreo_luz | Luz: ");
    Serial.println(val);
});

// ======= Patrones de parpadeo LED =======
// Alarma: 200ms ON, 400ms OFF
AsyncTask blinkAlarmaTask(200, true, []() {
    static bool ledState = false;
    ledState = !ledState;
    digitalWrite(LED_PIN, ledState);
    blinkAlarmaTask.SetIntervalMillis(ledState ? 200 : 400);
});

// Alerta: 100ms ON, 300ms OFF
AsyncTask blinkAlertaTask(100, true, []() {
    static bool ledState = false;
    ledState = !ledState;
    digitalWrite(LED_PIN, ledState);
    blinkAlertaTask.SetIntervalMillis(ledState ? 100 : 300);
});

// ======= Configuración de timeouts =======
void setTimeout(AsyncTask& task, unsigned long interval) {
    task.SetIntervalMillis(interval);
    task.Reset();
    task.Start();
}

// ======= Configuración de la máquina de estados =======
void setupStateMachine()
{
    // Transiciones entre estados
    stateMachine.AddTransition(Inicio, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_th, Monitoreo_luz, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_th, Alerta, []() { return (!isnan(currentTemp) && currentTemp > 27.0); });
    stateMachine.AddTransition(Alerta, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Alerta, Inicio, []() { return input == Input::A; });
    stateMachine.AddTransition(Monitoreo_luz, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_luz, Alarma, []() { return (currentLuz >= 0 && currentLuz > 512); });
    stateMachine.AddTransition(Alarma, Monitoreo_luz, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Alarma, Inicio, []() { return input == Input::B; });

    // Acciones al entrar a cada estado
    stateMachine.SetOnEntering(Inicio, []() {
        Serial.println("Estado: Inicio");
        setTimeout(timeoutInicio, 5000);
        digitalWrite(LED_PIN, LOW);
    });

    stateMachine.SetOnEntering(Monitoreo_th, []() {
        currentTemp = NAN;
        Serial.println("Estado: Monitoreo_th");
        setTimeout(timeoutMonThToLuz, 7000);
        readDHTTask.Start();
        digitalWrite(LED_PIN, LOW);
    });

    stateMachine.SetOnEntering(Alerta, []() {
        Serial.println("Estado: Alerta");
        setTimeout(timeoutAlertaToMonTh, 4000);
        blinkAlertaTask.Start();
    });

    stateMachine.SetOnEntering(Monitoreo_luz, []() {
        currentLuz = -1;
        Serial.println("Estado: Monitoreo_luz");
        setTimeout(timeoutMonLuzToTh, 2000);
        readLDRTask.Start();
        digitalWrite(LED_PIN, LOW);
    });

    stateMachine.SetOnEntering(Alarma, []() {
        Serial.println("Estado: Alarma");
        setTimeout(timeoutAlarmaToLuz, 5000);
        blinkAlarmaTask.Start();
    });

    // Acciones al salir de cada estado
    stateMachine.SetOnLeaving(Inicio, []() {
        input = Input::Unknown;
        timeoutInicio.Stop();
    });

    stateMachine.SetOnLeaving(Monitoreo_th, []() {
        input = Input::Unknown;
        timeoutMonThToLuz.Stop();
        readDHTTask.Stop();
    });

    stateMachine.SetOnLeaving(Alerta, []() {
        input = Input::Unknown;
        timeoutAlertaToMonTh.Stop();
        blinkAlertaTask.Stop();
        digitalWrite(LED_PIN, LOW);
    });

    stateMachine.SetOnLeaving(Monitoreo_luz, []() {
        input = Input::Unknown;
        timeoutMonLuzToTh.Stop();
        readLDRTask.Stop();
    });

    stateMachine.SetOnLeaving(Alarma, []() {
        input = Input::Unknown;
        timeoutAlarmaToLuz.Stop();
        blinkAlarmaTask.Stop();
        digitalWrite(LED_PIN, LOW);
    });
}

// ======= Configuración inicial =======
void setup()
{
    Serial.begin(9600);
    dht.begin();
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    setupStateMachine();
    stateMachine.SetState(Inicio, false, true);
}

// ======= Bucle principal =======
void loop()
{
    // Actualizar tareas de tiempo
    timeoutInicio.Update();
    timeoutMonThToLuz.Update();
    timeoutAlertaToMonTh.Update();
    timeoutMonLuzToTh.Update();
    timeoutAlarmaToLuz.Update();

    // Actualizar tareas de sensores y LED
    readDHTTask.Update();
    readLDRTask.Update();
    blinkAlarmaTask.Update();
    blinkAlertaTask.Update();

    // Leer entrada del usuario
    if (input == Input::Unknown) {
        input = static_cast<Input>(readInput());
    }

    // Actualizar máquina de estados
    stateMachine.Update();
}

// ======= Lectura de comandos seriales =======
int readInput()
{
    if (Serial.available())
    {
        char c = Serial.read();
        switch (c)
        {
            case 'A': return Input::A;  // Confirmar alerta
            case 'B': return Input::B;  // Confirmar alarma
            default: return Input::Unknown;
        }
    }
    return Input::Unknown;
}



