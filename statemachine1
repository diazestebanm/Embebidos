#include "StateMachineLib.h"
#include <AsyncTaskLib.h>
#include <DHT.h>

// ======= Pines / DHT =======
const uint8_t DHT_PIN = 2;    // DHT11 en digital 2
const uint8_t LDR_PIN = A0;   // LDR en A0 (Mega)
#define DHTTYPE DHT11
DHT dht(DHT_PIN, DHTTYPE);

// ======= Pines LED reales (añadidos, mínimos) =======
const uint8_t LED_AZUL = 8;   // Alerta
const uint8_t LED_ROJO = 9;   // Alarma

// ======= Estados e Inputs =======
enum State
{
    Inicio = 0,
    Monitoreo_th = 1,
    Alerta = 2,
    Monitoreo_luz = 3,
    Alarma = 4
};

enum Input
{
    H = 0,
    A = 1,
    L = 2,
    B = 3,
    Sign_Timeout = 4,
    Unknown = 5
};

// ======= Máquina =======
StateMachine stateMachine(5, 9);
Input input = Input::Unknown;

// ======= Variables para condiciones (mínimo añadido) =======
float currentTemp = NAN;
int currentLuz = 0;

// ======= Timeouts originales (cada uno dispara Sign_Timeout) =======
AsyncTask timeoutInicio(5000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutMonThToLuz(7000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutAlertaToMonTh(4000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutMonLuzToTh(2000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutAlarmaToLuz(5000, false, []() { input = Input::Sign_Timeout; });

// ======= Tareas de lectura (AsyncTask, no otra API) =======
AsyncTask readDHTTask(2000, false, []() {
    float h = dht.readHumidity();
    float t = dht.readTemperature();
    // actualizar variable necesaria para la nueva condición
    currentTemp = t;
    if (isnan(h) || isnan(t)) {
        // Mostrar estado y nota corta si falla
        Serial.println("Estado: Monitoreo_th | Temp: N/A | Hum: N/A");
    } else {
        Serial.print("Estado: Monitoreo_th | Temp: ");
        Serial.print(t);
        Serial.print("C | Hum: ");
        Serial.print(h);
        Serial.println("%");
    }
});

AsyncTask readLDRTask(500, false, []() {
    int val = analogRead(LDR_PIN); // 0..1023 en Mega
    // actualizar variable necesaria para la nueva condición
    currentLuz = val;
    Serial.print("Estado: Monitoreo_luz | Luz: ");
    Serial.println(val);
});

// ======= Tareas para LEDs REALES (reemplazan las impresiones por Serial) =======
// Alerta: Azul ON 100ms / OFF 300ms
bool alertaLedOn = false;
AsyncTask alertaLedTask(100, false, []() {
    if (alertaLedOn) {
        // Apagar LED azul
        digitalWrite(LED_AZUL, LOW);
        alertaLedOn = false;
        alertaLedTask.SetIntervalMillis(300); // OFF 300ms
    } else {
        // Encender LED azul
        digitalWrite(LED_AZUL, HIGH);
        alertaLedOn = true;
        alertaLedTask.SetIntervalMillis(100); // ON 100ms
    }
});

// Alarma: Rojo ON 200ms / OFF 400ms
bool alarmaLedOn = false;
AsyncTask alarmaLedTask(200, false, []() {
    if (alarmaLedOn) {
        // Apagar LED rojo
        digitalWrite(LED_ROJO, LOW);
        alarmaLedOn = false;
        alarmaLedTask.SetIntervalMillis(400); // OFF 400ms
    } else {
        // Encender LED rojo
        digitalWrite(LED_ROJO, HIGH);
        alarmaLedOn = true;
        alarmaLedTask.SetIntervalMillis(200); // ON 200ms
    }
});

// ======= Helper para configurar timeouts (misma técnica que antes) =======
void setTimeout(AsyncTask& task, unsigned long interval) {
    task.SetIntervalMillis(interval);
    task.Reset();
    task.Start();
}

// ======= Setup de la máquina de estados (con las dos transiciones modificadas) =======
void setupStateMachine()
{
    // Transiciones (idénticas salvo las dos condiciones requeridas)
    stateMachine.AddTransition(Inicio, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_th, Monitoreo_luz, []() { return input == Input::Sign_Timeout; });

    // REEMPLAZADA: antes era input == Input::H
    stateMachine.AddTransition(Monitoreo_th, Alerta, []() { return (isnan(currentTemp) ? false : (currentTemp > 27.0)); });

    stateMachine.AddTransition(Alerta, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Alerta, Inicio, []() { return input == Input::A; });
    stateMachine.AddTransition(Monitoreo_luz, Monitoreo_th, []() { return input == Input::Sign_Timeout; });

    // REEMPLAZADA: antes era input == Input::L
    stateMachine.AddTransition(Monitoreo_luz, Alarma, []() { return currentLuz > 512; });

    stateMachine.AddTransition(Alarma, Monitoreo_luz, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Alarma, Inicio, []() { return input == Input::B; });

    // On Enter (arrancamos las tareas correspondientes y configuramos timeouts)
    stateMachine.SetOnEntering(Inicio, []() {
        Serial.println("Estado: Inicio");
        setTimeout(timeoutInicio, 5000);
    });

    stateMachine.SetOnEntering(Monitoreo_th, []() {
        // Mensaje corto al entrar; las lecturas las imprime la tarea periódica
        Serial.println("Estado: Monitoreo_th");
        setTimeout(timeoutMonThToLuz, 7000);

        readDHTTask.SetIntervalMillis(2000);
        readDHTTask.Reset();
        readDHTTask.Start();
    });

    stateMachine.SetOnEntering(Alerta, []() {
        Serial.println("Estado: Alerta");
        setTimeout(timeoutAlertaToMonTh, 4000);

        alertaLedOn = false;
        alertaLedTask.SetIntervalMillis(100);
        alertaLedTask.Reset();
        alertaLedTask.Start();
    });

    stateMachine.SetOnEntering(Monitoreo_luz, []() {
        Serial.println("Estado: Monitoreo_luz");
        setTimeout(timeoutMonLuzToTh, 2000);

        readLDRTask.SetIntervalMillis(500);
        readLDRTask.Reset();
        readLDRTask.Start();
    });

    stateMachine.SetOnEntering(Alarma, []() {
        Serial.println("Estado: Alarma");
        setTimeout(timeoutAlarmaToLuz, 5000);

        alarmaLedOn = false;
        alarmaLedTask.SetIntervalMillis(200);
        alarmaLedTask.Reset();
        alarmaLedTask.Start();
    });

    // On Leaving (detenemos las tareas correspondientes y reseteamos input)
    stateMachine.SetOnLeaving(Inicio, []() {
        input = Input::Unknown;
        timeoutInicio.Stop();
    });

    stateMachine.SetOnLeaving(Monitoreo_th, []() {
        input = Input::Unknown;
        timeoutMonThToLuz.Stop();
        readDHTTask.Stop();
    });

    stateMachine.SetOnLeaving(Alerta, []() {
        input = Input::Unknown;
        timeoutAlertaToMonTh.Stop();
        alertaLedTask.Stop();
        digitalWrite(LED_AZUL, LOW); // apagar al salir
    });

    stateMachine.SetOnLeaving(Monitoreo_luz, []() {
        input = Input::Unknown;
        timeoutMonLuzToTh.Stop();
        readLDRTask.Stop();
    });

    stateMachine.SetOnLeaving(Alarma, []() {
        input = Input::Unknown;
        timeoutAlarmaToLuz.Stop();
        alarmaLedTask.Stop();
        digitalWrite(LED_ROJO, LOW); // apagar al salir
    });
}

// ======= Setup / Loop =======
void setup()
{
    Serial.begin(9600);
    dht.begin();

    // configurar pines LED (solo esto es nuevo)
    pinMode(LED_AZUL, OUTPUT);
    pinMode(LED_ROJO, OUTPUT);
    digitalWrite(LED_AZUL, LOW);
    digitalWrite(LED_ROJO, LOW);

    setupStateMachine();
    stateMachine.SetState(Inicio, false, true);
}

void loop()
{
    // Actualizar timeouts
    timeoutInicio.Update();
    timeoutMonThToLuz.Update();
    timeoutAlertaToMonTh.Update();
    timeoutMonLuzToTh.Update();
    timeoutAlarmaToLuz.Update();

    // Actualizar tareas sensores y LEDs
    readDHTTask.Update();
    readLDRTask.Update();
    alertaLedTask.Update();
    alarmaLedTask.Update();

    // Leer entrada del usuario (si no hay señal activa)
    if (input == Input::Unknown) {
        input = static_cast<Input>(readInput());
    }

    // Actualizar máquina
    stateMachine.Update();
}

// ======= Lectura serial de comandos =======
int readInput()
{
    if (Serial.available())
    {
        char c = Serial.read();
        switch (c)
        {
            case 'H': return Input::H;
            case 'A': return Input::A;
            case 'L': return Input::L;
            case 'B': return Input::B;
            default: return Input::Unknown;
        }
    }
    return Input::Unknown;
}

