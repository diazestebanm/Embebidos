#include "StateMachineLib.h"
#include <AsyncTaskLib.h>
#include <DHT.h>

// ======= Pines =======
const uint8_t DHT_PIN = 2;    // DHT11
const uint8_t LDR_PIN = A0;   // LDR
const uint8_t LED_PIN = 13;   // LED para alarma

#define DHTTYPE DHT11
DHT dht(DHT_PIN, DHTTYPE);

// ======= Estados e Inputs =======
enum State
{
    Inicio = 0,
    Monitoreo_th = 1,
    Alerta = 2,
    Monitoreo_luz = 3,
    Alarma = 4
};

enum Input
{
    H = 0,
    A = 1,
    L = 2,
    B = 3,
    Sign_Timeout = 4,
    Unknown = 5
};

// ======= MÃ¡quina =======
StateMachine stateMachine(5, 9);
Input input = Input::Unknown;

// ======= Variables =======
float currentTemp = NAN;
int currentLuz = -1;

// ======= Timeouts =======
AsyncTask timeoutInicio(5000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutMonThToLuz(7000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutAlertaToMonTh(4000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutMonLuzToTh(2000, false, []() { input = Input::Sign_Timeout; });
AsyncTask timeoutAlarmaToLuz(5000, false, []() { input = Input::Sign_Timeout; });

// ======= Tareas =======
AsyncTask readDHTTask(2000, false, []() {
    float h = dht.readHumidity();
    float t = dht.readTemperature();
    currentTemp = t;
    if (isnan(h) || isnan(t)) {
        Serial.println("Estado: Monitoreo_th | Temp: N/A | Hum: N/A");
    } else {
        Serial.print("Estado: Monitoreo_th | Temp: ");
        Serial.print(t);
        Serial.print("C | Hum: ");
        Serial.print(h);
        Serial.println("%");
    }
});

AsyncTask readLDRTask(500, false, []() {
    int val = analogRead(LDR_PIN);
    currentLuz = val;
    Serial.print("Estado: Monitoreo_luz | Luz: ");
    Serial.println(val);
});

// === LED parpadeo para Alarma ===
AsyncTask blinkLedTask(200, true, []() {
    static bool ledState = false;
    digitalWrite(LED_PIN, ledState);
    ledState = !ledState;

    // Cambiar el intervalo segÃºn estado ON/OFF
    if (ledState) {
        blinkLedTask.SetIntervalMillis(200); // Encendido 200ms
    } else {
        blinkLedTask.SetIntervalMillis(400); // Apagado 400ms
    }
});

// ======= Helper =======
void setTimeout(AsyncTask& task, unsigned long interval) {
    task.SetIntervalMillis(interval);
    task.Reset();
    task.Start();
}

// ======= MÃ¡quina =======
void setupStateMachine()
{
    // Transiciones
    stateMachine.AddTransition(Inicio, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_th, Monitoreo_luz, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_th, Alerta, []() { return (isnan(currentTemp) ? false : (currentTemp > 27.0)); });
    stateMachine.AddTransition(Alerta, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Alerta, Inicio, []() { return input == Input::A; });
    stateMachine.AddTransition(Monitoreo_luz, Monitoreo_th, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Monitoreo_luz, Alarma, []() { return (currentLuz >= 0 && currentLuz > 512); });
    stateMachine.AddTransition(Alarma, Monitoreo_luz, []() { return input == Input::Sign_Timeout; });
    stateMachine.AddTransition(Alarma, Inicio, []() { return input == Input::B; });

    // On Enter
    stateMachine.SetOnEntering(Inicio, []() {
        Serial.println("Estado: Inicio");
        setTimeout(timeoutInicio, 5000);
    });

    stateMachine.SetOnEntering(Monitoreo_th, []() {
        currentTemp = NAN;
        Serial.println("Estado: Monitoreo_th");
        setTimeout(timeoutMonThToLuz, 7000);
        readDHTTask.Start();
    });

    stateMachine.SetOnEntering(Alerta, []() {
        Serial.println("Estado: Alerta");
        setTimeout(timeoutAlertaToMonTh, 4000);
    });

    stateMachine.SetOnEntering(Monitoreo_luz, []() {
        currentLuz = -1;
        Serial.println("Estado: Monitoreo_luz");
        setTimeout(timeoutMonLuzToTh, 2000);
        readLDRTask.Start();
    });

    stateMachine.SetOnEntering(Alarma, []() {
        Serial.println("Estado: Alarma");
        setTimeout(timeoutAlarmaToLuz, 5000);
        blinkLedTask.Start(); // ðŸ”´ Iniciar parpadeo LED
    });

    // On Leaving
    stateMachine.SetOnLeaving(Inicio, []() {
        input = Input::Unknown;
        timeoutInicio.Stop();
    });

    stateMachine.SetOnLeaving(Monitoreo_th, []() {
        input = Input::Unknown;
        timeoutMonThToLuz.Stop();
        readDHTTask.Stop();
    });

    stateMachine.SetOnLeaving(Alerta, []() {
        input = Input::Unknown;
        timeoutAlertaToMonTh.Stop();
    });

    stateMachine.SetOnLeaving(Monitoreo_luz, []() {
        input = Input::Unknown;
        timeoutMonLuzToTh.Stop();
        readLDRTask.Stop();
    });

    stateMachine.SetOnLeaving(Alarma, []() {
        input = Input::Unknown;
        timeoutAlarmaToLuz.Stop();
        blinkLedTask.Stop();      // ðŸ”´ Detener parpadeo
        digitalWrite(LED_PIN, LOW); // Apagar LED al salir
    });
}

// ======= Setup / Loop =======
void setup()
{
    Serial.begin(9600);
    pinMode(LED_PIN, OUTPUT); // Configurar LED
    dht.begin();
    setupStateMachine();
    stateMachine.SetState(Inicio, false, true);
}

void loop()
{
    // Actualizar timeouts
    timeoutInicio.Update();
    timeoutMonThToLuz.Update();
    timeoutAlertaToMonTh.Update();
    timeoutMonLuzToTh.Update();
    timeoutAlarmaToLuz.Update();

    // Actualizar tareas
    readDHTTask.Update();
    readLDRTask.Update();
    blinkLedTask.Update(); // ðŸ”´ Actualizar parpadeo

    // Leer entrada
    if (input == Input::Unknown) {
        input = static_cast<Input>(readInput());
    }

    // Actualizar mÃ¡quina
    stateMachine.Update();
}

// ======= Lectura serial =======
int readInput()
{
    if (Serial.available())
    {
        char c = Serial.read();
        switch (c)
        {
            case 'H': return Input::H;
            case 'A': return Input::A;
            case 'L': return Input::L;
            case 'B': return Input::B;
            default: return Input::Unknown;
        }
    }
    return Input::Unknown;
}


